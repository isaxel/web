## 1. Безопасность и JWT

### Как работает JWT (JSON Web Token)?

JWT — это компактный, самодостаточный способ передачи информации между сторонами в виде объекта JSON.

* **Структура:** Состоит из трех частей, разделенных точками: `Header.Payload.Signature`.
* **Header:** Тип токена и алгоритм хеширования (например, HS256).
* **Payload:** Данные (claims), такие как `user_id`, `exp` (истечение).
* **Signature:** Хеш от заголовка и полезной нагрузки, созданный с использованием секретного ключа.


* **Механизм:** Сервер выдает токен после логина. Клиент присылает его в заголовке `Authorization: Bearer <token>`. Сервер проверяет подпись. Если она верна — данным в Payload можно доверять без запроса к БД.

### Почему TLS 1.3 запрещает renegotiation?

В TLS 1.2 "пересогласование" (renegotiation) часто использовалось для запроса клиентского сертификата посреди сессии. Однако это создавало дыры в безопасности (Triple Handshake Attack) и сильно усложняло протокол.

* **Влияние на REST API:** Теперь нельзя сначала пустить пользователя анонимно, а потом «на лету» (по конкретному URL) потребовать сертификат. В TLS 1.3 для этого используется механизм **Post-Handshake Authentication**, который должен поддерживаться и клиентом, и сервером.

### Почему bcrypt лучше SHA-256 для паролей?

SHA-256 — быстрый алгоритм. Злоумышленник может перебирать миллионы хешей в секунду.
**Bcrypt** специально сделан медленным. Он включает в себя:

1. **Salt (Соль):** Защищает от радужных таблиц.
2. **Work Factor (Cost):** Параметр, замедляющий вычисление. Если через 5 лет компьютеры станут в 10 раз быстрее, вы просто увеличите Cost, и взлом снова станет невыгодным.

### CSP (Content Security Policy) и Nonce-based подход

CSP — это заголовок ответа сервера, который говорит браузеру, из каких источников можно загружать скрипты.

* **White-list доменов:** Сложно поддерживать. Если в разрешенном домене (например, CDN) есть уязвимость, злоумышленник ее использует.
* **Nonce-based:** Сервер генерирует случайное одноразовое число (nonce) для каждого запроса и добавляет его в заголовок и в тег `<script nonce="...">`. Скрипт без правильного nonce просто не выполнится. Это надежнее, так как nonce невозможно предугадать.

---

## 2. Java EE / Jakarta EE

### JNDI & RMI

* **RMI (Remote Method Invocation):** Позволяет объекту в одной JVM вызывать методы объекта в другой JVM. Это фундамент для распределенных систем в Java.
* **JNDI (Java Naming and Directory Interface):** Это «телефонный справочник» для Java-объектов. Компоненты (например, DataSource или EJB) регистрируются в JNDI под логическими именами, а другие компоненты их там находят (lookup).

### CDI: Стереотипы и Scopes

* **Стереотипы (@Stereotype):** Это аннотация, которая объединяет несколько других аннотаций. Например, `@Model` — это встроенный стереотип, включающий `@Named` и `@RequestScoped`. Удобно, чтобы не писать по 5 аннотаций над каждым классом.
* **Scopes (Области видимости):**
* `@RequestScoped`: Живет один HTTP-запрос.
* `@SessionScoped`: Живет, пока жива сессия пользователя.
* `@ApplicationScoped`: Один экземпляр на всё приложение.
* `@Dependent`: По умолчанию. Живет столько же, сколько объект, в который он внедрен.



### EJB: Stateless vs Stateful

* **Stateless Session Beans:** Не хранят состояние клиента между вызовами. Эффективны, так как сервер может использовать пул из нескольких бинов для тысяч клиентов.
* **Stateful Session Beans:** Хранят состояние конкретного клиента (например, корзина покупок). Дороже для памяти, так как фиксируются за сессией.
* **EJB Lite vs Full:** Lite — подмножество технологий (только Session Beans, без JMS и удаленных вызовов), которое влезает в обычный Web-профиль. Full — весь "фарш".

### Location Transparency

Это принцип, согласно которому вызывающему коду неважно, где находится компонент — в той же JVM или на другом сервере в кластере. В Java EE это реализуется через EJB и JNDI: вы просто делаете инъекцию интерфейса, а контейнер сам разруливает сетевое взаимодействие.

---

## 3. Spring Framework

### BeanPostProcessor и AOP

* **BeanPostProcessor:** Интерфейс, который позволяет вмешаться в процесс создания бина. У него два метода: `postProcessBeforeInitialization` и `postProcessAfterInitialization`. Именно здесь Spring может обернуть ваш бин в прокси.
* **Spring AOP:** Использует прокси для добавления "аспектов" (логирование, транзакции).
* **JDK Dynamic Proxy:** Используется, если ваш класс реализует интерфейс.
* **CGLib:** Используется, если интерфейсов нет (создает подкласс вашего класса на лету).



### @Primary vs @Qualifier

Если в контексте два бина одного типа:

* `@Primary`: Помечает один из них как "главный" по умолчанию.
* `@Qualifier("name")`: Позволяет точно указать имя бина, который нужно внедрить в конкретном месте.

### Load-time Weaving (LTW)

Это способ внедрения аспектов прямо в момент загрузки классов в JVM (через Java Agent). Это мощнее, чем стандартное Spring AOP, так как позволяет обрабатывать даже те вызовы, которые происходят внутри одного и того же класса.

---

## 4. Frontend: React

### Reconciliation и Virtual DOM

**Virtual DOM (VDOM)** — это копия реального DOM в памяти в виде JS-объектов.

1. При изменении состояния React создает новое дерево VDOM.
2. **Reconciliation:** Процесс сравнения старого дерева с новым (диффинг).
3. React находит минимальный набор изменений и применяет их к реальному DOM.

**Зачем нужен `key`?** Ключи помогают React понять, какие элементы списка изменились, были добавлены или удалены. Без ключей при перемещении элемента React может перерисовать весь список целиком, что ударит по производительности.

### React Fiber

Это новый движок реконсиляции (с версии 16).

* **Двойное дерево:** У Fiber есть `current` дерево (то, что на экране) и `work-in-progress` дерево.
* **Атомарный коммит:** React может прерывать работу над `work-in-progress` деревом (например, чтобы обработать ввод пользователя), а когда всё готово — мгновенно заменить `current` на новое дерево. Если в процессе возникла ошибка, он просто выбрасывает незавершенное дерево.

### useMemo vs useCallback

* `useMemo`: Кэширует **результат** вычислений.
* `useCallback`: Кэширует саму **функцию**.
Оба нужны, чтобы избежать лишних перерисовок дочерних компонентов при изменении ссылок на объекты/функции.

---

## 5. Frontend: Angular

### Incremental DOM (Ivy)

В отличие от React, Angular (начиная с Ivy) не использует VDOM. Он использует **Incremental DOM**.

* Компоненты компилируются в инструкции, которые обновляют DOM напрямую.
* **Преимущество:** Если какая-то часть Angular не используется, она просто не попадет в бандл (Tree Shaking), так как нет огромного "движка VDOM", который должен быть там целиком. Также это потребляет меньше памяти.

### Change Detection и ViewContainerRef

Если вы создаете компонент динамически через `ViewContainerRef`, Angular может "забыть" включить его в дерево проверки изменений. Чтобы он обновлялся, нужно либо вызвать `changeDetectorRef.detectChanges()`, либо убедиться, что компонент прикреплен к Change Detection циклу родителя.

### Модули, Компоненты, Сервисы

* **Component:** Логика + Шаблон (UI).
* **Service:** Бизнес-логика, общая для компонентов.
* **Module (NgModule):** Контейнер, объединяющий связанные компоненты и сервисы.
* **DI (Dependency Injection):** В Angular DI встроен на уровне иерархии. Вы можете прокинуть сервис на уровне всего приложения или только для одного компонента.

---

## 6. Общая архитектура и REST

### Идемпотентность POST-запросов

POST по стандарту не идемпотентен (два запроса = два заказа). Если клиент словил таймаут и шлет POST снова, мы можем получить дубликат.
**Решение:** Клиент генерирует уникальный `Idempotency-Key` (UUID) и шлет его в заголовке. Сервер сохраняет этот ключ в БД/Redis. Если приходит второй запрос с тем же ключом — сервер просто возвращает старый результат, не выполняя операцию снова.

### Island Architecture (Astro)

Традиционные SPA грузят тонны JS, даже если страница — это просто текст. "Острова" позволяют рендерить страницу как чистый HTML, и только маленькие интерактивные части (виджеты) "оживлять" с помощью JavaScript. Это дает бешеную скорость загрузки (Core Web Vitals).

### 401 vs 403

* **401 Unauthorized:** "Я не знаю, кто ты. Пожалуйста, предъяви паспорт (логин)".
* **403 Forbidden:** "Я знаю, кто ты, но тебе сюда нельзя. У тебя нет прав доступа".

